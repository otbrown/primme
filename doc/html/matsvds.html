<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>MATLAB Interface &#8212; PRIMME 2.1 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Parameter Description" href="appendixsvds.html" />
    <link rel="prev" title="Python Interface" href="pysvds.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="readme.html">
              <img class="logo" src="_static/logo.png" alt="Logo"/>
            </a></p><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="readme.html">Documentation overview</a><ul>
  <li><a href="apisvds.html">Singular Value Problems</a><ul>
      <li>Previous: <a href="pysvds.html" title="previous chapter">Python Interface</a></li>
      <li>Next: <a href="appendixsvds.html" title="next chapter">Parameter Description</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/matsvds.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="matlab-interface">
<h1>MATLAB Interface<a class="headerlink" href="#matlab-interface" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt>
<code class="descname">function [varargout] = primme_svds(varargin)</code></dt>
<dd><p><code class="xref mat mat-func docutils literal"><span class="pre">primme_svds()</span></code> finds a few singular values and vectors of a matrix <code class="docutils literal"><span class="pre">A</span></code>
by calling <a class="reference external" href="https://github.com/primme/primme">PRIMME</a>. <code class="docutils literal"><span class="pre">A</span></code> is typically large and sparse.</p>
<p><code class="docutils literal"><span class="pre">S</span> <span class="pre">=</span> <span class="pre">primme_svds(A)</span></code> returns a vector with the 6 largest singular values of <code class="docutils literal"><span class="pre">A</span></code>.</p>
<p><code class="docutils literal"><span class="pre">S</span> <span class="pre">=</span> <span class="pre">primme_svds(AFUN,M,N)</span></code> accepts the function handle <code class="docutils literal"><span class="pre">AFUN</span></code> to perform
the matrix vector products with an M-by-N matrix <code class="docutils literal"><span class="pre">A</span></code>.
<code class="docutils literal"><span class="pre">AFUN(X,'notransp')</span></code> returns <code class="docutils literal"><span class="pre">A*X</span></code> while <code class="docutils literal"><span class="pre">AFUN(X,'transp')</span></code> returns <code class="docutils literal"><span class="pre">A’*X</span></code>.
In all the following, <code class="docutils literal"><span class="pre">A</span></code> can be replaced by <code class="docutils literal"><span class="pre">AFUN,M,N</span></code>.</p>
<p><code class="docutils literal"><span class="pre">S</span> <span class="pre">=</span> <span class="pre">primme_svds(A,k)</span></code> computes the <code class="docutils literal"><span class="pre">k</span></code> largest singular values of <code class="docutils literal"><span class="pre">A</span></code>.</p>
<p><code class="docutils literal"><span class="pre">S</span> <span class="pre">=</span> <span class="pre">primme_svds(A,k,sigma)</span></code> computes the <code class="docutils literal"><span class="pre">k</span></code> singular values closest to the
scalar shift <code class="docutils literal"><span class="pre">sigma</span></code>.</p>
<blockquote>
<div><ul class="simple">
<li>If <code class="docutils literal"><span class="pre">sigma</span></code> is a vector, find the singular value <code class="docutils literal"><span class="pre">S(i)</span></code> closest to each <code class="docutils literal"><span class="pre">sigma(i)</span></code>, for <code class="docutils literal"><span class="pre">i&lt;=k</span></code>.</li>
<li>If <code class="docutils literal"><span class="pre">sigma</span></code> is <code class="docutils literal"><span class="pre">'L'</span></code>, it computes the largest singular values.</li>
<li>if <code class="docutils literal"><span class="pre">sigma</span></code> is <code class="docutils literal"><span class="pre">'S'</span></code>, it computes the smallest singular values.</li>
</ul>
</div></blockquote>
<p><code class="docutils literal"><span class="pre">S</span> <span class="pre">=</span> <span class="pre">primme_svds(A,k,sigma,OPTIONS)</span></code> specifies extra solver parameters.
Some default values are indicated in brackets {}:</p>
<blockquote>
<div><ul>
<li><p class="first"><a class="reference internal" href="appendixsvds.html#c.primme_svds_params.aNorm" title="primme_svds_params.aNorm"><code class="xref c c-member docutils literal"><span class="pre">aNorm</span></code></a>:    estimation of the 2-norm of <code class="docutils literal"><span class="pre">A</span></code> {0.0 (estimate the norm internally)}</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">tol</span></code>:     convergence tolerance <code class="docutils literal"><span class="pre">NORM([A*V-U*S;A'*U-V*S])</span> <span class="pre">&lt;=</span> <span class="pre">tol</span> <span class="pre">*</span> <span class="pre">NORM(A)</span></code> (see <a class="reference internal" href="appendixsvds.html#c.primme_svds_params.eps" title="primme_svds_params.eps"><code class="xref c c-member docutils literal"><span class="pre">eps</span></code></a>) { <code class="docutils literal"><span class="pre">1e-10</span></code>}</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">maxit</span></code>:   maximum number of matvecs with <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">A'</span></code> (see <a class="reference internal" href="appendixsvds.html#c.primme_svds_params.maxMatvecs" title="primme_svds_params.maxMatvecs"><code class="xref c c-member docutils literal"><span class="pre">maxMatvecs</span></code></a>)  {inf}</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">p</span></code>:       maximum basis size (see <a class="reference internal" href="appendixsvds.html#c.primme_svds_params.maxBasisSize" title="primme_svds_params.maxBasisSize"><code class="xref c c-member docutils literal"><span class="pre">maxBasisSize</span></code></a>)</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">disp</span></code>:    level of reporting 0-3 (see HIST) {0: no output}</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">isreal</span></code>:  if 0, the matrix is complex; else it&#8217;s real {0: complex}</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">isdouble</span></code>: if 0, the matrix is single; else it&#8217;s double {1: double}</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">method</span></code>:  which equivalent eigenproblem to solve</p>
<blockquote>
<div><ul class="simple">
<li>&#8216;<a class="reference internal" href="appendixsvds.html#c.primme_svds_preset_method.primme_svds_normalequations" title="primme_svds_preset_method.primme_svds_normalequations"><code class="xref c c-member docutils literal"><span class="pre">primme_svds_normalequations</span></code></a>&#8216;: <code class="docutils literal"><span class="pre">A'*A</span></code> or <code class="docutils literal"><span class="pre">A*A'</span></code></li>
<li>&#8216;<a class="reference internal" href="appendixsvds.html#c.primme_svds_preset_method.primme_svds_augmented" title="primme_svds_preset_method.primme_svds_augmented"><code class="xref c c-member docutils literal"><span class="pre">primme_svds_augmented</span></code></a>&#8216;: <code class="docutils literal"><span class="pre">[0</span> <span class="pre">A';A</span> <span class="pre">0]</span></code></li>
<li>&#8216;<a class="reference internal" href="appendixsvds.html#c.primme_svds_preset_method.primme_svds_hybrid" title="primme_svds_preset_method.primme_svds_hybrid"><code class="xref c c-member docutils literal"><span class="pre">primme_svds_hybrid</span></code></a>&#8216;: first normal equations and then augmented (default)</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">u0</span></code>:       initial guesses to the left singular vectors (see <a class="reference internal" href="appendixsvds.html#c.primme_svds_params.initSize" title="primme_svds_params.initSize"><code class="xref c c-member docutils literal"><span class="pre">initSize</span></code></a>) {[]}</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">v0</span></code>:       initial guesses to the right singular vectors {[]}</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">orthoConst</span></code>: external orthogonalization constraints (see <a class="reference internal" href="appendixsvds.html#c.primme_svds_params.numOrthoConst" title="primme_svds_params.numOrthoConst"><code class="xref c c-member docutils literal"><span class="pre">numOrthoConst</span></code></a>) {[]}</p>
</li>
<li><p class="first"><a class="reference internal" href="appendixsvds.html#c.primme_svds_params.locking" title="primme_svds_params.locking"><code class="xref c c-member docutils literal"><span class="pre">locking</span></code></a>:  1, hard locking; 0, soft locking</p>
</li>
<li><p class="first"><a class="reference internal" href="appendixsvds.html#c.primme_svds_params.maxBlockSize" title="primme_svds_params.maxBlockSize"><code class="xref c c-member docutils literal"><span class="pre">maxBlockSize</span></code></a>: maximum block size</p>
</li>
<li><p class="first"><a class="reference internal" href="appendixsvds.html#c.primme_svds_params.iseed" title="primme_svds_params.iseed"><code class="xref c c-member docutils literal"><span class="pre">iseed</span></code></a>:    random seed</p>
</li>
<li><p class="first"><a class="reference internal" href="appendixsvds.html#c.primme_svds_params.primme" title="primme_svds_params.primme"><code class="xref c c-member docutils literal"><span class="pre">primme</span></code></a>:   options for first stage solver</p>
</li>
<li><p class="first"><a class="reference internal" href="appendixsvds.html#c.primme_svds_params.primmeStage2" title="primme_svds_params.primmeStage2"><code class="xref c c-member docutils literal"><span class="pre">primmeStage2</span></code></a>: options for second stage solver</p>
</li>
</ul>
</div></blockquote>
<p>The available options for <code class="docutils literal"><span class="pre">OPTIONS.primme</span></code> and <code class="docutils literal"><span class="pre">primmeStage2</span></code> are
the same as <code class="xref mat mat-func docutils literal"><span class="pre">primme_eigs()</span></code>, plus the option <code class="docutils literal"><span class="pre">'method'</span></code>.</p>
<p><code class="docutils literal"><span class="pre">S</span> <span class="pre">=</span> <span class="pre">primme_svds(A,k,sigma,OPTIONS,P)</span></code> applies a preconditioner <code class="docutils literal"><span class="pre">P</span></code> as follows:</p>
<blockquote>
<div><ul class="simple">
<li>If <code class="docutils literal"><span class="pre">P</span></code> is a matrix it applies <code class="docutils literal"><span class="pre">P\X</span></code> and <code class="docutils literal"><span class="pre">P'\X</span></code> to approximate <code class="docutils literal"><span class="pre">A\X</span></code> and <code class="docutils literal"><span class="pre">A'\X</span></code>.</li>
<li>If <code class="docutils literal"><span class="pre">P</span></code> is a function handle, <code class="docutils literal"><span class="pre">PFUN</span></code>, <code class="docutils literal"><span class="pre">PFUN(X,'notransp')</span></code> returns <code class="docutils literal"><span class="pre">P\X</span></code> and
<code class="docutils literal"><span class="pre">PFUN(X,'transp')</span></code> returns <code class="docutils literal"><span class="pre">P’\X</span></code>, approximating <code class="docutils literal"><span class="pre">A\X</span></code> and <code class="docutils literal"><span class="pre">A'\X</span></code> respectively.</li>
<li><dl class="first docutils">
<dt>If <code class="docutils literal"><span class="pre">P</span></code> is a <code class="docutils literal"><span class="pre">struct</span></code>, it can have one or more of the following fields:</dt>
<dd><code class="docutils literal"><span class="pre">P.AHA\X</span></code> or <code class="docutils literal"><span class="pre">P.AHA(X)</span></code> returns an approximation of <code class="docutils literal"><span class="pre">(A'*A)\X</span></code>,
<code class="docutils literal"><span class="pre">P.AAH\X</span></code> or <code class="docutils literal"><span class="pre">P.AAH(X)</span></code> returns an approximation of <code class="docutils literal"><span class="pre">(A*A')\X</span></code>,
<code class="docutils literal"><span class="pre">P.aug\X</span></code> or <code class="docutils literal"><span class="pre">P.aug(X)</span></code> returns an approximation of <code class="docutils literal"><span class="pre">[zeros(N,N)</span> <span class="pre">A';A</span> <span class="pre">zeros(M,M)]\X</span></code>.</dd>
</dl>
</li>
<li>If <code class="docutils literal"><span class="pre">P</span></code> is <code class="docutils literal"><span class="pre">[]</span></code> then no preconditioner is applied.</li>
</ul>
</div></blockquote>
<p><code class="docutils literal"><span class="pre">S</span> <span class="pre">=</span> <span class="pre">primme_svds(A,k,sigma,OPTIONS,P1,P2</span></code>) applies a factorized preconditioner:</p>
<blockquote>
<div><ul class="simple">
<li>If both <code class="docutils literal"><span class="pre">P1</span></code> and <code class="docutils literal"><span class="pre">P2</span></code> are nonempty, apply <code class="docutils literal"><span class="pre">(P1*P2)\X</span></code> to approximate <code class="docutils literal"><span class="pre">A\X</span></code>.</li>
<li>If <code class="docutils literal"><span class="pre">P1</span></code> is <code class="docutils literal"><span class="pre">[]</span></code> and <code class="docutils literal"><span class="pre">P2</span></code> is nonempty, then <code class="docutils literal"><span class="pre">(P2'*P2)\X</span></code> approximates <code class="docutils literal"><span class="pre">A'*A</span></code>.
<code class="docutils literal"><span class="pre">P2</span></code> can be the R factor of an (incomplete) QR factorization of <code class="docutils literal"><span class="pre">A</span></code> or
the L factor of an (incomplete) LL&#8217; factorization of <code class="docutils literal"><span class="pre">A'*A</span></code> (RIF).</li>
<li>If both <code class="docutils literal"><span class="pre">P1</span></code> and <code class="docutils literal"><span class="pre">P2</span></code> are <code class="docutils literal"><span class="pre">[]</span></code> then no preconditioner is applied.</li>
</ul>
</div></blockquote>
<p><code class="docutils literal"><span class="pre">[U,S,V]</span> <span class="pre">=</span> <span class="pre">primme_svds(...)</span></code> returns also the corresponding singular vectors.
If <code class="docutils literal"><span class="pre">A</span></code> is M-by-N and <code class="docutils literal"><span class="pre">k</span></code> singular triplets are computed, then <code class="docutils literal"><span class="pre">U</span></code> is M-by-k
with orthonormal columns, <code class="docutils literal"><span class="pre">S</span></code> is k-by-k diagonal, and <code class="docutils literal"><span class="pre">V</span></code> is N-by-k with
orthonormal columns.</p>
<p><code class="docutils literal"><span class="pre">[S,R]</span> <span class="pre">=</span> <span class="pre">primme_svds(...)</span></code></p>
<p><code class="docutils literal"><span class="pre">[U,S,V,R]</span> <span class="pre">=</span> <span class="pre">primme_svds(...)</span></code> returns the residual norm
of each <code class="docutils literal"><span class="pre">k</span></code> triplet, <code class="docutils literal"><span class="pre">NORM([A*V(:,i)-S(i,i)*U(:,i);</span> <span class="pre">A'*U(:,i)-S(i,i)*V(:,i)])</span></code>.</p>
<p><code class="docutils literal"><span class="pre">[U,S,V,R,STATS]</span> <span class="pre">=</span> <span class="pre">primme_svds(...)</span></code> returns how many times <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">P</span></code> were
used and elapsed time. The application of <code class="docutils literal"><span class="pre">A</span></code> is counted independently from
the application of <code class="docutils literal"><span class="pre">A'</span></code>.</p>
<p><code class="docutils literal"><span class="pre">[U,S,V,R,STATS,HIST]</span> <span class="pre">=</span> <span class="pre">primme_svds(...)</span></code> returns the convergence history,
instead of printing it. Every row is a record, and the columns report:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">HIST(:,1)</span></code>: number of matvecs</li>
<li><code class="docutils literal"><span class="pre">HIST(:,2)</span></code>: time</li>
<li><code class="docutils literal"><span class="pre">HIST(:,3)</span></code>: number of converged/locked triplets</li>
<li><code class="docutils literal"><span class="pre">HIST(:,4)</span></code>: stage</li>
<li><code class="docutils literal"><span class="pre">HIST(:,5)</span></code>: block index</li>
<li><code class="docutils literal"><span class="pre">HIST(:,6)</span></code>: approximate singular value</li>
<li><code class="docutils literal"><span class="pre">HIST(:,7)</span></code>: residual norm</li>
<li><code class="docutils literal"><span class="pre">HIST(:,8)</span></code>: QMR residual norm</li>
</ul>
</div></blockquote>
<p><code class="docutils literal"><span class="pre">OPTS.disp</span></code> controls the granularity of the record. If <code class="docutils literal"><span class="pre">OPTS.disp</span> <span class="pre">==</span> <span class="pre">1</span></code>, <code class="docutils literal"><span class="pre">HIST</span></code>
has one row per converged triplet and only the first four columns are
reported; if <code class="docutils literal"><span class="pre">OPTS.disp</span> <span class="pre">==</span> <span class="pre">2</span></code>, <code class="docutils literal"><span class="pre">HIST</span></code> has one row per outer iteration and only
the first seven columns are reported; and otherwise <code class="docutils literal"><span class="pre">HIST</span></code> has one row per QMR
iteration and all columns are reported.</p>
<p>Examples:</p>
<div class="highlight-matlab"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="p">=</span> <span class="nb">diag</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">50</span><span class="p">);</span> <span class="n">A</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c">% rectangular matrix of size 200x50</span>

<span class="n">s</span> <span class="p">=</span> <span class="n">primme_svds</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span> <span class="c">% the 10 largest singular values</span>

<span class="n">s</span> <span class="p">=</span> <span class="n">primme_svds</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="s">&#39;S&#39;</span><span class="p">)</span> <span class="c">% the 10 smallest singular values</span>

<span class="n">s</span> <span class="p">=</span> <span class="n">primme_svds</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">25</span><span class="p">)</span> <span class="c">% the 10 closest singular values to 25</span>

<span class="n">opts</span> <span class="p">=</span> <span class="n">struct</span><span class="p">();</span>
<span class="n">opts</span><span class="p">.</span><span class="n">tol</span> <span class="p">=</span> <span class="mf">1e-4</span><span class="p">;</span> <span class="c">% set tolerance</span>
<span class="n">opts</span><span class="p">.</span><span class="n">method</span> <span class="p">=</span> <span class="s">&#39;primme_svds_normalequations&#39;</span> <span class="c">% set svd solver method</span>
<span class="n">opts</span><span class="p">.</span><span class="n">primme</span><span class="p">.</span><span class="n">method</span> <span class="p">=</span> <span class="s">&#39;DEFAULT_MIN_TIME&#39;</span> <span class="c">% set first stage eigensolver method</span>
<span class="n">opts</span><span class="p">.</span><span class="n">primme</span><span class="p">.</span><span class="n">maxBlockSize</span> <span class="p">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c">% set block size for first stage</span>
<span class="p">[</span><span class="n">u</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">v</span><span class="p">]</span> <span class="p">=</span> <span class="n">primme_svds</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="s">&#39;S&#39;</span><span class="p">,</span><span class="n">opts</span><span class="p">);</span> <span class="c">% find 10 smallest svd triplets</span>

<span class="n">opts</span><span class="p">.</span><span class="n">orthoConst</span> <span class="p">=</span> <span class="p">{</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">};</span>
<span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="n">rnorms</span><span class="p">]</span> <span class="p">=</span> <span class="n">primme_svds</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="s">&#39;S&#39;</span><span class="p">,</span><span class="n">opts</span><span class="p">)</span> <span class="c">% find another 10</span>

<span class="c">% Compute the 5 smallest singular values of a rectangular matrix using</span>
<span class="c">% Jacobi preconditioner on (A&#39;*A)</span>
<span class="n">A</span> <span class="p">=</span> <span class="n">sparse</span><span class="p">(</span><span class="nb">diag</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">50</span><span class="p">)</span> <span class="o">+</span> <span class="nb">diag</span><span class="p">(</span><span class="nb">ones</span><span class="p">(</span><span class="mi">49</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">));</span>
<span class="n">A</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span><span class="mi">50</span><span class="p">)</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c">% size(A)=[200 50]</span>
<span class="n">Pstruct</span> <span class="p">=</span> <span class="n">struct</span><span class="p">(</span><span class="s">&#39;AHA&#39;</span><span class="p">,</span> <span class="nb">diag</span><span class="p">(</span><span class="n">A</span><span class="o">&#39;*</span><span class="n">A</span><span class="p">),</span><span class="c">...</span>
                 <span class="s">&#39;AAH&#39;</span><span class="p">,</span> <span class="nb">ones</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="s">&#39;aug&#39;</span><span class="p">,</span> <span class="nb">ones</span><span class="p">(</span><span class="mi">250</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>
<span class="n">Pfun</span> <span class="p">=</span> <span class="p">@(</span><span class="n">x</span><span class="p">,</span><span class="n">mode</span><span class="p">)</span><span class="n">Pstruct</span><span class="p">.(</span><span class="n">mode</span><span class="p">)</span><span class="o">.\</span><span class="n">x</span><span class="p">;</span>
<span class="n">s</span> <span class="p">=</span> <span class="n">primme_svds</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="s">&#39;S&#39;</span><span class="p">,[],</span><span class="n">Pfun</span><span class="p">)</span> <span class="c">% find the 5 smallest values</span>
</pre></div>
</div>
<p>See also: <a class="reference external" href="https://www.mathworks.com/help/matlab/ref/svds.html">MATLAB svds</a>, <code class="xref mat mat-func docutils literal"><span class="pre">primme_eigs()</span></code></p>
</dd></dl>

</div>


          </div>
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2017, College of William & Mary.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="_sources/matsvds.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>